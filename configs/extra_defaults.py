from detectron2.config import CfgNode as CN

_C = CN()

# Logging
_C.CONFIG_PATH = ""
_C.TRAINING_PATHS = []
_C.VALIDATION_PATHS = []

# Save name configuration while training, RUN_DIR will add a timestamp, NAME will add a custom name
_C.RUN_DIR = True
_C.NAME = ""

# Automatically filled do not expect values to remain
_C.LAYPA_UUID = ""
_C.LAYPA_GIT_HASH = ""
_C.SETUP_TIME = ""

# Model changes
_C.MODEL = CN()
_C.MODEL.RESUME = False
_C.MODEL.MODE = ""

_C.MODEL.SEM_SEG_HEAD = CN()
_C.MODEL.SEM_SEG_HEAD.WEIGHT = [1.0]

_C.MODEL.BINARY_SEG_HEAD = CN()
_C.MODEL.BINARY_SEG_HEAD.NAME = "BinarySegFPNHead"
_C.MODEL.BINARY_SEG_HEAD.IN_FEATURES = ["p2", "p3", "p4", "p5"]
# Label in the semantic segmentation ground truth that is ignored, i.e., no loss is calculated for
# the correposnding pixel.
_C.MODEL.BINARY_SEG_HEAD.IGNORE_VALUE = 255
# Number of classes in the semantic segmentation head
_C.MODEL.BINARY_SEG_HEAD.NUM_CLASSES = 54
# Number of channels in the 3x3 convs inside semantic-FPN heads.
_C.MODEL.BINARY_SEG_HEAD.CONVS_DIM = 128
# Outputs from semantic-FPN heads are up-scaled to the COMMON_STRIDE stride.
_C.MODEL.BINARY_SEG_HEAD.COMMON_STRIDE = 4
# Normalization method for the convolution layers. Options: "" (no norm), "GN".
_C.MODEL.BINARY_SEG_HEAD.NORM = "GN"
_C.MODEL.BINARY_SEG_HEAD.LOSS_WEIGHT = 1.0

# Automatic mixed precision settings
_C.MODEL.AMP_TRAIN = CN()
_C.MODEL.AMP_TRAIN.ENABLED = False
_C.MODEL.AMP_TRAIN.PRECISION = "bfloat16"
_C.MODEL.AMP_TEST = CN()
_C.MODEL.AMP_TEST.ENABLED = False
_C.MODEL.AMP_TEST.PRECISION = "bfloat16"

# Weights loaded during training
_C.TRAIN = CN()
_C.TRAIN.WEIGHTS = ""

# Weights loaded during testing/inference
_C.TEST = CN()
_C.TEST.WEIGHTS = ""

# Preprocessing
_C.PREPROCESS = CN()

_C.PREPROCESS.OUTPUT = [
    ("image", "png"),
    ("sem_seg", "png"),
    ("instances", "json"),
    ("pano", "png"),
]

# Preprocessing check if files specified in .txt file exist
_C.PREPROCESS.DISABLE_CHECK = False

# Overwrite existing files in temporary directory
_C.PREPROCESS.OVERWRITE = False

# PageXML region conversion
_C.PREPROCESS.REGION = CN()
_C.PREPROCESS.REGION.REGIONS = []
_C.PREPROCESS.REGION.MERGE_REGIONS = []
_C.PREPROCESS.REGION.REGION_TYPE = []
_C.PREPROCESS.REGION.RECTANGLE_REGIONS = []
_C.PREPROCESS.REGION.MIN_REGION_SIZE = 10

# PageXML baseline conversion
_C.PREPROCESS.BASELINE = CN()
_C.PREPROCESS.BASELINE.LINE_WIDTH = 5
_C.PREPROCESS.BASELINE.SQUARE_LINES = False

# Preprocessing resizing options
_C.PREPROCESS.RESIZE = CN()
_C.PREPROCESS.RESIZE.USE = False
_C.PREPROCESS.RESIZE.RESIZE_MODE = "shortest_edge"
_C.PREPROCESS.RESIZE.SCALING = 1.0
_C.PREPROCESS.RESIZE.RESIZE_SAMPLING = "choice"
_C.PREPROCESS.RESIZE.MIN_SIZE = [1024]
_C.PREPROCESS.RESIZE.MAX_SIZE = 2048

# DPI correction in resizing
_C.PREPROCESS.DPI = CN()
_C.PREPROCESS.DPI.AUTO_DETECT = False
_C.PREPROCESS.DPI.DEFAULT_DPI = 300
_C.PREPROCESS.DPI.TARGET_DPI = 300
_C.PREPROCESS.DPI.MANUAL_DPI = 300

_C.DATALOADER = CN()
_C.DATALOADER.PIN_MEMORY = True

_C.INPUT = CN()

# Run decoding and augmentation on GPU
_C.INPUT.ON_GPU = False

# Input augmentation

# Random flip
_C.INPUT.RANDOM_FLIP = "both"

# Resize options after loading image
_C.INPUT.RESIZE_MODE = "shortest_edge"
_C.INPUT.CROP_RESIZE = False
_C.INPUT.SCALING = 0.0
_C.INPUT.SCALING_TRAIN = 0.5
_C.INPUT.SCALING_TEST = 0.0

# DPI correction in resizing
_C.INPUT.DPI = CN()
_C.INPUT.DPI.AUTO_DETECT_TEST = False
_C.INPUT.DPI.DEFAULT_DPI_TEST = 300
_C.INPUT.DPI.TARGET_DPI_TEST = 300
_C.INPUT.DPI.MANUAL_DPI_TEST = 300

_C.INPUT.DPI.AUTO_DETECT_TRAIN = False
_C.INPUT.DPI.DEFAULT_DPI_TRAIN = 300
_C.INPUT.DPI.TARGET_DPI_TRAIN = 300
_C.INPUT.DPI.MANUAL_DPI_TRAIN = 300

# Convert entire image to grayscale
_C.INPUT.GRAYSCALE = CN()
_C.INPUT.GRAYSCALE.PROBABILITY = 0.0

# Adaptive thresholding to binarize image
_C.INPUT.ADAPTIVE_THRESHOLDING = CN()
_C.INPUT.ADAPTIVE_THRESHOLDING.PROBABILITY = 0.0

# Invert image
_C.INPUT.INVERT = CN()
_C.INPUT.INVERT.PROBABILITY = 0.0
_C.INPUT.INVERT.MAX_VALUE = 255

# Random JPEG compression to deal with compression artifacts
_C.INPUT.JPEG_COMPRESSION = CN()
_C.INPUT.JPEG_COMPRESSION.PROBABILITY = 0.0
_C.INPUT.JPEG_COMPRESSION.MIN_QUALITY = 0
_C.INPUT.JPEG_COMPRESSION.MAX_QUALITY = 100

# Add noise to image
_C.INPUT.NOISE = CN()
_C.INPUT.NOISE.PROBABILITY = 0.0
_C.INPUT.NOISE.MIN_STD = 0
_C.INPUT.NOISE.MAX_STD = 50

# Random brightness
_C.INPUT.BRIGHTNESS = CN()
_C.INPUT.BRIGHTNESS.PROBABILITY = 0.0
_C.INPUT.BRIGHTNESS.MIN_INTENSITY = 0.5
_C.INPUT.BRIGHTNESS.MAX_INTENSITY = 1.5

# Random contrast
_C.INPUT.CONTRAST = CN()
_C.INPUT.CONTRAST.PROBABILITY = 0.0
_C.INPUT.CONTRAST.MIN_INTENSITY = 0.5
_C.INPUT.CONTRAST.MAX_INTENSITY = 1.5

# Random saturation
_C.INPUT.SATURATION = CN()
_C.INPUT.SATURATION.PROBABILITY = 0.0
_C.INPUT.SATURATION.MIN_INTENSITY = 0.5
_C.INPUT.SATURATION.MAX_INTENSITY = 1.5

# Random hue
_C.INPUT.HUE = CN()
_C.INPUT.HUE.PROBABILITY = 0.0
_C.INPUT.HUE.MIN_DELTA = -0.5
_C.INPUT.HUE.MAX_DELTA = 0.5

# Random Gaussian filter (blur)
_C.INPUT.GAUSSIAN_FILTER = CN()
_C.INPUT.GAUSSIAN_FILTER.PROBABILITY = 0.0
_C.INPUT.GAUSSIAN_FILTER.MIN_SIGMA = 0.0
_C.INPUT.GAUSSIAN_FILTER.MAX_SIGMA = 3.0

# Horizontal flip
_C.INPUT.HORIZONTAL_FLIP = CN()
_C.INPUT.HORIZONTAL_FLIP.PROBABILITY = 0.0

# Vertical flip
_C.INPUT.VERTICAL_FLIP = CN()
_C.INPUT.VERTICAL_FLIP.PROBABILITY = 0.0

# Elastic deformation
_C.INPUT.ELASTIC_DEFORMATION = CN()
_C.INPUT.ELASTIC_DEFORMATION.PROBABILITY = 0.0
_C.INPUT.ELASTIC_DEFORMATION.ALPHA = 0.1
_C.INPUT.ELASTIC_DEFORMATION.SIGMA = 0.01

# Affine transformations
_C.INPUT.AFFINE = CN()
_C.INPUT.AFFINE.PROBABILITY = 0.0

_C.INPUT.AFFINE.TRANSLATION = CN()
_C.INPUT.AFFINE.TRANSLATION.PROBABILITY = 0.5
_C.INPUT.AFFINE.TRANSLATION.STANDARD_DEVIATION = 0.02

_C.INPUT.AFFINE.ROTATION = CN()
_C.INPUT.AFFINE.ROTATION.PROBABILITY = 0.5
_C.INPUT.AFFINE.ROTATION.KAPPA = 30.0

_C.INPUT.AFFINE.SHEAR = CN()
_C.INPUT.AFFINE.SHEAR.PROBABILITY = 0.5
_C.INPUT.AFFINE.SHEAR.KAPPA = 20.0

_C.INPUT.AFFINE.SCALE = CN()
_C.INPUT.AFFINE.SCALE.PROBABILITY = 0.5
_C.INPUT.AFFINE.SCALE.STANDARD_DEVIATION = 0.12

# Change orientation (rotate 0, 90, 180, 270 degrees)
_C.INPUT.ORIENTATION = CN()
_C.INPUT.ORIENTATION.PROBABILITY = 1.0
_C.INPUT.ORIENTATION.PERCENTAGES = [1.0, 0.0, 0.0, 0.0]


# Postprocessing
_C.POSTPROCESS = CN()
_C.POSTPROCESS.EXTERNAL = CN()
_C.POSTPROCESS.EXTERNAL.ENABLED = True
_C.POSTPROCESS.EXTERNAL.GRAYSCALE = True


# Solver
_C.SOLVER = CN()
# weight decay on embedding
_C.SOLVER.WEIGHT_DECAY_EMBED = 0.0
# optimizer
_C.SOLVER.OPTIMIZER = "ADAMW"
_C.SOLVER.BACKBONE_MULTIPLIER = 0.1
_C.SOLVER.AMSGRAD = True
